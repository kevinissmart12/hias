{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar Distance = require(\"./distance.js\"),\n  eudist = Distance.eudist,\n  dist = Distance.dist;\nmodule.exports = {\n  kmrand: function kmrand(data, k) {\n    var map = {},\n      ks = [],\n      t = k << 2;\n    var len = data.length;\n    var multi = data[0].length > 0;\n    while (ks.length < k && t-- > 0) {\n      var d = data[Math.floor(Math.random() * len)];\n      var key = multi ? d.join(\"_\") : \"\" + d;\n      if (!map[key]) {\n        map[key] = true;\n        ks.push(d);\n      }\n    }\n    if (ks.length < k) throw new Error(\"Error initializating clusters\");else return ks;\n  },\n  /**\n   * K-means++ initial centroid selection\n   */\n  kmpp: function kmpp(data, k) {\n    var distance = data[0].length ? eudist : dist;\n    var ks = [],\n      len = data.length;\n    var multi = data[0].length > 0;\n    var map = {};\n\n    // First random centroid\n    var c = data[Math.floor(Math.random() * len)];\n    var key = multi ? c.join(\"_\") : \"\" + c;\n    ks.push(c);\n    map[key] = true;\n\n    // Retrieve next centroids\n    while (ks.length < k) {\n      // Min Distances between current centroids and data points\n      var dists = [],\n        lk = ks.length;\n      var dsum = 0,\n        prs = [];\n      for (var i = 0; i < len; i++) {\n        var min = Infinity;\n        for (var j = 0; j < lk; j++) {\n          var _dist = distance(data[i], ks[j]);\n          if (_dist <= min) min = _dist;\n        }\n        dists[i] = min;\n      }\n\n      // Sum all min distances\n      for (var _i = 0; _i < len; _i++) {\n        dsum += dists[_i];\n      }\n\n      // Probabilities and cummulative prob (cumsum)\n      for (var _i2 = 0; _i2 < len; _i2++) {\n        prs[_i2] = {\n          i: _i2,\n          v: data[_i2],\n          pr: dists[_i2] / dsum,\n          cs: 0\n        };\n      }\n\n      // Sort Probabilities\n      prs.sort(function (a, b) {\n        return a.pr - b.pr;\n      });\n\n      // Cummulative Probabilities\n      prs[0].cs = prs[0].pr;\n      for (var _i3 = 1; _i3 < len; _i3++) {\n        prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;\n      }\n\n      // Randomize\n      var rnd = Math.random();\n\n      // Gets only the items whose cumsum >= rnd\n      var idx = 0;\n      while (idx < len - 1 && prs[idx++].cs < rnd) {}\n      ks.push(prs[idx - 1].v);\n      /*\n      let done = false;\n      while(!done) {\n      \t// this is our new centroid\n      \tc = prs[idx-1].v\n      \tkey = multi? c.join(\"_\") : `${c}`;\n      \tif(!map[key]) {\n      \t\tmap[key] = true;\n      \t\tks.push(c);\n      \t\tdone = true;\n      \t}\n      \telse {\n      \t\tidx++;\n      \t}\n      }\n      */\n    }\n\n    return ks;\n  }\n};","map":{"version":3,"mappings":"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","names":["Distance","require","eudist","dist","module","exports","kmrand","data","k","map","ks","t","len","length","multi","d","Math","floor","random","key","join","push","Error","kmpp","distance","c","dists","lk","dsum","prs","i","min","Infinity","j","v","pr","cs","sort","a","b","rnd","idx"],"sources":["../../kinit.js"],"sourcesContent":["const\n\tDistance = require(\"./distance.js\"),\n\teudist = Distance.eudist,\n\tdist = Distance.dist;\n\nmodule.exports = {\n\tkmrand(data,k) {\n\t\tvar map = {}, ks = [], t = k<<2;\n\t\tvar len = data.length;\n\t\tvar multi = data[0].length>0;\n\n\t\twhile(ks.length<k && (t--)>0) {\n\t\t\tlet d = data[Math.floor(Math.random()*len)];\n\t\t\tlet key = multi? d.join(\"_\") : `${d}`;\n\t\t\tif(!map[key]) {\n\t\t\t\tmap[key] = true;\n\t\t\t\tks.push(d);\n\t\t\t}\n\t\t}\n\n\t\tif(ks.length<k) throw new Error(\"Error initializating clusters\");\n\t\telse return ks;\n\t},\n\n\t/**\n\t * K-means++ initial centroid selection\n\t */\n\tkmpp(data,k) {\n\t\tvar distance = data[0].length? eudist : dist;\n\t\tvar ks = [], len = data.length;\n\t\tvar multi = data[0].length>0;\n\t\tvar map = {};\n\n\t\t// First random centroid\n\t\tvar c = data[Math.floor(Math.random()*len)];\n\t\tvar key = multi? c.join(\"_\") : `${c}`;\n\t\tks.push(c);\n\t\tmap[key] = true;\n\n\t\t// Retrieve next centroids\n\t\twhile(ks.length<k) {\n\t\t\t// Min Distances between current centroids and data points\n\t\t\tlet dists = [], lk = ks.length;\n\t\t\tlet dsum = 0, prs = [];\n\n\t\t\tfor(let i=0;i<len;i++) {\n\t\t\t\tlet min = Infinity;\n\t\t\t\tfor(let j=0;j<lk;j++) {\n\t\t\t\t\tlet dist = distance(data[i],ks[j]);\n\t\t\t\t\tif(dist<=min) min = dist;\n\t\t\t\t}\n\t\t\t\tdists[i] = min;\n\t\t\t}\n\n\t\t\t// Sum all min distances\n\t\t\tfor(let i=0;i<len;i++) {\n\t\t\t\tdsum += dists[i]\n\t\t\t}\n\n\t\t\t// Probabilities and cummulative prob (cumsum)\n\t\t\tfor(let i=0;i<len;i++) {\n\t\t\t\tprs[i] = {i:i, v:data[i],\tpr:dists[i]/dsum, cs:0}\n\t\t\t}\n\n\t\t\t// Sort Probabilities\n\t\t\tprs.sort((a,b)=>a.pr-b.pr);\n\n\t\t\t// Cummulative Probabilities\n\t\t\tprs[0].cs = prs[0].pr;\n\t\t\tfor(let i=1;i<len;i++) {\n\t\t\t\tprs[i].cs = prs[i-1].cs + prs[i].pr;\n\t\t\t}\n\n\t\t\t// Randomize\n\t\t\tlet rnd = Math.random();\n\n\t\t\t// Gets only the items whose cumsum >= rnd\n\t\t\tlet idx = 0;\n\t\t\twhile(idx<len-1 && prs[idx++].cs<rnd);\n\t\t\tks.push(prs[idx-1].v);\n\t\t\t/*\n\t\t\tlet done = false;\n\t\t\twhile(!done) {\n\t\t\t\t// this is our new centroid\n\t\t\t\tc = prs[idx-1].v\n\t\t\t\tkey = multi? c.join(\"_\") : `${c}`;\n\t\t\t\tif(!map[key]) {\n\t\t\t\t\tmap[key] = true;\n\t\t\t\t\tks.push(c);\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\treturn ks;\n\t}\n\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}