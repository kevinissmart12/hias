{"ast":null,"code":"\"use strict\";\n\n/*jshint esversion: 6 */\nrequire(\"core-js/modules/es.array.push.js\");\nvar Distance = require(\"./distance.js\"),\n  ClusterInit = require(\"./kinit.js\"),\n  eudist = Distance.eudist,\n  mandist = Distance.mandist,\n  dist = Distance.dist,\n  kmrand = ClusterInit.kmrand,\n  kmpp = ClusterInit.kmpp;\nvar MAX = 10000;\n\n/**\n * Inits an array with values\n */\nfunction init(len, val, v) {\n  v = v || [];\n  for (var i = 0; i < len; i++) {\n    v[i] = val;\n  }\n  return v;\n}\nfunction skmeans(data, k, initial, maxit) {\n  var ks = [],\n    old = [],\n    idxs = [],\n    dist = [];\n  var conv = false,\n    it = maxit || MAX;\n  var len = data.length,\n    vlen = data[0].length,\n    multi = vlen > 0;\n  var count = [];\n  if (!initial) {\n    var _idxs = {};\n    while (ks.length < k) {\n      var idx = Math.floor(Math.random() * len);\n      if (!_idxs[idx]) {\n        _idxs[idx] = true;\n        ks.push(data[idx]);\n      }\n    }\n  } else if (initial == \"kmrand\") {\n    ks = kmrand(data, k);\n  } else if (initial == \"kmpp\") {\n    ks = kmpp(data, k);\n  } else {\n    ks = initial;\n  }\n  do {\n    // Reset k count\n    init(k, 0, count);\n\n    // For each value in data, find the nearest centroid\n    for (var i = 0; i < len; i++) {\n      var min = Infinity,\n        _idx = 0;\n      for (var j = 0; j < k; j++) {\n        // Multidimensional or unidimensional\n        var dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);\n        if (dist <= min) {\n          min = dist;\n          _idx = j;\n        }\n      }\n      idxs[i] = _idx; // Index of the selected centroid for that value\n      count[_idx]++; // Number of values for this centroid\n    }\n\n    // Recalculate centroids\n    var sum = [],\n      old = [],\n      dif = 0;\n    for (var _j = 0; _j < k; _j++) {\n      // Multidimensional or unidimensional\n      sum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;\n      old[_j] = ks[_j];\n    }\n\n    // If multidimensional\n    if (multi) {\n      for (var _j2 = 0; _j2 < k; _j2++) {\n        ks[_j2] = [];\n      } // Sum values and count for each centroid\n      for (var _i = 0; _i < len; _i++) {\n        var _idx2 = idxs[_i],\n          // Centroid for that item\n          vsum = sum[_idx2],\n          // Sum values for this centroid\n          vect = data[_i]; // Current vector\n\n        // Accumulate value on the centroid for current vector\n        for (var h = 0; h < vlen; h++) {\n          vsum[h] += vect[h];\n        }\n      }\n      // Calculate the average for each centroid\n      conv = true;\n      for (var _j3 = 0; _j3 < k; _j3++) {\n        var ksj = ks[_j3],\n          // Current centroid\n          sumj = sum[_j3],\n          // Accumulated centroid values\n          oldj = old[_j3],\n          // Old centroid value\n          cj = count[_j3]; // Number of elements for this centroid\n\n        // New average\n        for (var _h = 0; _h < vlen; _h++) {\n          ksj[_h] = sumj[_h] / cj || 0; // New centroid\n        }\n\n        // Find if centroids have moved\n        if (conv) {\n          for (var _h2 = 0; _h2 < vlen; _h2++) {\n            if (oldj[_h2] != ksj[_h2]) {\n              conv = false;\n              break;\n            }\n          }\n        }\n      }\n    }\n    // If unidimensional\n    else {\n      // Sum values and count for each centroid\n      for (var _i2 = 0; _i2 < len; _i2++) {\n        var _idx3 = idxs[_i2];\n        sum[_idx3] += data[_i2];\n      }\n      // Calculate the average for each centroid\n      for (var _j4 = 0; _j4 < k; _j4++) {\n        ks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid\n      }\n      // Find if centroids have moved\n      conv = true;\n      for (var _j5 = 0; _j5 < k; _j5++) {\n        if (old[_j5] != ks[_j5]) {\n          conv = false;\n          break;\n        }\n      }\n    }\n    conv = conv || --it <= 0;\n  } while (!conv);\n  return {\n    it: MAX - it,\n    k: k,\n    idxs: idxs,\n    centroids: ks\n  };\n}\nmodule.exports = skmeans;","map":{"version":3,"mappings":"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","names":["Distance","require","ClusterInit","eudist","mandist","dist","kmrand","kmpp","MAX","init","len","val","v","i","skmeans","data","k","initial","maxit","ks","old","idxs","conv","it","length","vlen","multi","count","idx","Math","floor","random","push","min","Infinity","j","abs","sum","dif","vsum","vect","h","ksj","sumj","oldj","cj","centroids","module","exports"],"sources":["../../main.js"],"sourcesContent":["/*jshint esversion: 6 */\n\nconst\n\tDistance = require(\"./distance.js\"),\n\tClusterInit = require(\"./kinit.js\"),\n\teudist = Distance.eudist,\n\tmandist = Distance.mandist,\n\tdist = Distance.dist,\n\tkmrand = ClusterInit.kmrand,\n\tkmpp = ClusterInit.kmpp;\n\nconst MAX = 10000;\n\n/**\n * Inits an array with values\n */\nfunction init(len,val,v) {\n\tv = v || [];\n\tfor(let i=0;i<len;i++) v[i] = val;\n\treturn v;\n}\n\nfunction skmeans(data,k,initial,maxit) {\n\tvar ks = [], old = [], idxs = [], dist = [];\n\tvar conv = false, it = maxit || MAX;\n\tvar len = data.length, vlen = data[0].length, multi = vlen>0;\n\tvar count = [];\n\n\tif(!initial) {\n\t\tlet idxs = {};\n\t\twhile(ks.length<k) {\n\t\t\tlet idx = Math.floor(Math.random()*len);\n\t\t\tif(!idxs[idx]) {\n\t\t\t\tidxs[idx] = true;\n\t\t\t\tks.push(data[idx]);\n\t\t\t}\n\t\t}\n\t}\n\telse if(initial==\"kmrand\") {\n\t\tks = kmrand(data,k);\n\t}\n\telse if(initial==\"kmpp\") {\n\t\tks = kmpp(data,k);\n\t}\n\telse {\n\t\tks = initial;\n\t}\n\n\tdo {\n\t\t// Reset k count\n\t\tinit(k,0,count);\n\n\t\t// For each value in data, find the nearest centroid\n\t\tfor(let i=0;i<len;i++) {\n\t\t\tlet min = Infinity, idx = 0;\n\t\t\tfor(let j=0;j<k;j++) {\n\t\t\t\t// Multidimensional or unidimensional\n\t\t\t\tvar dist = multi? eudist(data[i],ks[j]) : Math.abs(data[i]-ks[j]);\n\t\t\t\tif(dist<=min) {\n\t\t\t\t\tmin = dist;\n\t\t\t\t\tidx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidxs[i] = idx;\t// Index of the selected centroid for that value\n\t\t\tcount[idx]++;\t\t// Number of values for this centroid\n\t\t}\n\n\t\t// Recalculate centroids\n\t\tvar sum = [], old = [], dif = 0;\n\t\tfor(let j=0;j<k;j++) {\n\t\t\t// Multidimensional or unidimensional\n\t\t\tsum[j] = multi? init(vlen,0,sum[j]) : 0;\n\t\t\told[j] = ks[j];\n\t\t}\n\n\t\t// If multidimensional\n\t\tif(multi) {\n\t\t\tfor(let j=0;j<k;j++) ks[j] = [];\n\n\t\t\t// Sum values and count for each centroid\n\t\t\tfor(let i=0;i<len;i++) {\n\t\t\t\tlet\tidx = idxs[i],\t\t// Centroid for that item\n\t\t\t\t\t\tvsum = sum[idx],\t// Sum values for this centroid\n\t\t\t\t\t\tvect = data[i];\t\t// Current vector\n\n\t\t\t\t// Accumulate value on the centroid for current vector\n\t\t\t\tfor(let h=0;h<vlen;h++) {\n\t\t\t\t\tvsum[h] += vect[h];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Calculate the average for each centroid\n\t\t\tconv = true;\n\t\t\tfor(let j=0;j<k;j++) {\n\t\t\t\tlet ksj = ks[j],\t\t// Current centroid\n\t\t\t\t\t\tsumj = sum[j],\t// Accumulated centroid values\n\t\t\t\t\t\toldj = old[j], \t// Old centroid value\n\t\t\t\t\t\tcj = count[j];\t// Number of elements for this centroid\n\n\t\t\t\t// New average\n\t\t\t\tfor(let h=0;h<vlen;h++) {\n\t\t\t\t\tksj[h] = (sumj[h])/(cj) || 0;\t// New centroid\n\t\t\t\t}\n\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tif(conv) {\n\t\t\t\t\tfor(let h=0;h<vlen;h++) {\n\t\t\t\t\t\tif(oldj[h]!=ksj[h]) {\n\t\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If unidimensional\n\t\telse {\n\t\t\t// Sum values and count for each centroid\n\t\t\tfor(let i=0;i<len;i++) {\n\t\t\t\tlet idx = idxs[i];\n\t\t\t\tsum[idx] += data[i];\n\t\t\t}\n\t\t\t// Calculate the average for each centroid\n\t\t\tfor(let j=0;j<k;j++) {\n\t\t\t\tks[j] = sum[j]/count[j] || 0;\t// New centroid\n\t\t\t}\n\t\t\t// Find if centroids have moved\n\t\t\tconv = true;\n\t\t\tfor(let j=0;j<k;j++) {\n\t\t\t\tif(old[j]!=ks[j]) {\n\t\t\t\t\tconv = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconv = conv || (--it<=0);\n\t}while(!conv);\n\n\treturn {\n\t\tit : MAX-it,\n\t\tk : k,\n\t\tidxs : idxs,\n\t\tcentroids : ks\n\t};\n}\n\nmodule.exports = skmeans;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}