{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * @file 几何计算器\n * @author dengshufang01 [Flora]\n*/\nimport { midpoint, centroid, point, distance, lineString, length, area, union, booleanDisjoint, booleanContains, booleanPointOnLine, booleanPointInPolygon, pointToLineDistance, nearestPointOnLine, rhumbDistance } from '@turf/turf';\nexport var GeoCalculator = {\n  // 获取线段中点\n  getLineCenter: function getLineCenter(point1, point2) {\n    if (point1 instanceof BMapGL.Point && point2 instanceof BMapGL.Point) {\n      point1 = point([point1.lng, point1.lat]);\n      point2 = point([point2.lng, point2.lat]);\n    }\n    var geoCenter = midpoint(point1, point2);\n    var bdCenter = new BMapGL.Point(geoCenter.geometry.coordinates[0], geoCenter.geometry.coordinates[1]);\n    return {\n      geoCenter: geoCenter,\n      bdCenter: bdCenter\n    };\n  },\n  // 获取两点间距离\n  getDistance: function getDistance(point1, point2) {\n    var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'kilometers';\n    if (point1 instanceof BMapGL.Point && point2 instanceof BMapGL.Point) {\n      point1 = point([point1.lng, point1.lat]);\n      point2 = point([point2.lng, point2.lat]);\n    }\n    var options = {\n      units: unit\n    };\n    return distance(point1, point2, options);\n  },\n  /**\n      * 获取折线总距离\n      * @param line <GeoJSON> 折线\n      * @param unit 可选返回值单位，默认为km\n     */\n  getLength: function getLength(line) {\n    var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'kilometers';\n    return length(line, {\n      units: unit\n    });\n  },\n  /**\n   * 获取多边形区域中心\n   * @param poly geojson\n   * @return 中心点，包括 geojson 和 BMap.Point 两种格式\n  */\n  getPolygonCenter: function getPolygonCenter(poly) {\n    var geoCenter = centroid(poly);\n    var bdCenter = new BMapGL.Point(geoCenter.geometry.coordinates[0], geoCenter.geometry.coordinates[1]);\n    return {\n      geoCenter: geoCenter,\n      bdCenter: bdCenter\n    };\n  },\n  /**\n   * 获取多边形或矩形面积\n   * @param overlay <geojson | BMapGL.Polygon> 覆盖物\n   * @return 区域面积，单位：平方千米\n  */\n  getPolygonArea: function getPolygonArea(overlay) {\n    if (overlay instanceof BMapGL.Polygon) {\n      overlay = overlay.toGeoJSON();\n    }\n    return area(overlay) / 1000000;\n  },\n  /**\n   * 组合多边形\n   * @param polygons 两个或多个geojson格式的多边形\n   * @return 一个组合多边形\n   */\n  unionPolygon: function unionPolygon(polygons) {\n    var poly = polygons[0];\n    for (var i = 0, len = polygons.length; i < len; i++) {\n      poly = union(poly, polygons[i]);\n    }\n    return poly;\n  },\n  /**\n   * 判断两个几何图形是否相交\n   * @param geometry1 geojson格式的几何图形\n   * @param geometry2 geojson格式的几何图形\n   * @return 如果相交返回true\n   */\n  isDisjoint: function isDisjoint(geometry1, geometry2) {\n    return !booleanDisjoint(geometry1, geometry2);\n  },\n  /**\n   * 判断inputs数据是否与target数据相交\n   * @param inputs 相交运算数据集合，GeoJSON或者Overlay结构数据的数组\n   * @param target 相交运算数据，GeoJSON或者Overlay结构\n   * @returns 返回相交的数据集合，默认为[]\n   */\n  intersect: function intersect(inputs, target) {\n    var result = [];\n    if (target.__proto__ instanceof BMapGL.Overlay) {\n      if (target.toGeoJSON) {\n        target = target.toGeoJSON();\n      } else {\n        return result;\n      }\n    }\n    inputs.forEach(function (item) {\n      var _item = item;\n      if (item.__proto__ instanceof BMapGL.Overlay) {\n        if (item.toGeoJSON) {\n          _item = item.toGeoJSON();\n        } else {\n          return true;\n        }\n      }\n      var isPass = GeoCalculator.isDisjoint(_item, target);\n      if (isPass) {\n        result.push(item);\n      }\n    });\n    return result;\n  },\n  /**\n   * 判断几何图形是否包含\n   * @param outPoly geojson格式的几何图形，用于外部框选图形\n   * @param inPoly geojson格式的几何图形，用于内部被选图形\n   * @return 如果inPoly完全包含在outPoly内，返回true\n  */\n  isContains: function isContains(outPoly, inPoly) {\n    return booleanContains(outPoly, inPoly);\n  },\n  /**\n   * 判断点是否在线上\n   * @param pt <geojson | BMapGL.Point> 点\n   * @param line <GeoJSON | BMapGL.Polyline> 线\n   * @param opts <object> 可选配置忽略line的起始点与结束点\n   * @return <boolean> 点是否在线上\n  */\n  isPointOnLine: function isPointOnLine(pt, line) {\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      ignoreEndVertices: false\n    };\n    if (pt instanceof BMapGL.Point) {\n      pt = pt.toGeoJSON();\n    }\n    if (line instanceof BMapGL.Polyline) {\n      line = line.toGeoJSON();\n    }\n    return booleanPointOnLine(pt, line, opts);\n  },\n  /**\n   * 判断点是否在几何体内\n   * @param pt <geojson | BMapGL.Point> 点\n   * @param poly <geojson> 几何体（多边形、圆形、矩形）\n   * @param opts <object> 可选配置，是否包含多边形边界\n   * @return 如果在多边形内返回true\n   */\n  isPointInPolygon: function isPointInPolygon(pt, poly) {\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      ignoreBoundary: true\n    };\n    if (pt instanceof BMapGL.Point) {\n      pt = pt.toGeoJSON();\n    }\n    if (poly instanceof BMapGL.Polygon) {\n      poly = poly.toGeoJSON();\n    }\n    return booleanPointInPolygon(pt, poly, opts);\n  },\n  /**\n   * \n   * 获取点到多线段最短距离\n   * @param point 点\n   * @param points 点数组,一般getPath()获取\n   * @return 点到多线段最短距离，单位：千米\n   */\n  getDistance2Lines: function getDistance2Lines(pot, points) {\n    var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'kilometers';\n    var geoPoint = point([pot.lng, pot.lat]);\n    var line = lineString(points);\n    return pointToLineDistance(geoPoint, line);\n  },\n  /**\n   * 计算点到多线段最短间距点\n   */\n  getNearestPointOnLine: function getNearestPointOnLine(pot, geoOverlay) {\n    var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'kilometers';\n    var geoPoint = point([pot.lng, pot.lat]);\n    var coordinates = [];\n    if (geoOverlay.geometry.type === 'Polygon') {\n      coordinates = geoOverlay.geometry.coordinates[0];\n    } else if (geoOverlay.geometry.type === 'LineString') {\n      coordinates = geoOverlay.geometry.coordinates;\n    }\n    var line = lineString(coordinates);\n    var geoNearestPoint = nearestPointOnLine(line, geoPoint, unit);\n    var bdNearestPoint = new BMapGL.Point(geoNearestPoint.geometry.coordinates[0], geoNearestPoint.geometry.coordinates[1]);\n    var toLineDistance = distance(geoPoint, geoNearestPoint);\n    return {\n      geoPoint: geoPoint,\n      geoNearestPoint: geoNearestPoint,\n      toLineDistance: toLineDistance,\n      bdNearestPoint: bdNearestPoint\n    };\n  }\n};","map":{"version":3,"names":["midpoint","centroid","point","distance","lineString","length","area","union","booleanDisjoint","booleanContains","booleanPointOnLine","booleanPointInPolygon","pointToLineDistance","nearestPointOnLine","rhumbDistance","GeoCalculator","getLineCenter","point1","point2","BMapGL","Point","lng","lat","geoCenter","bdCenter","geometry","coordinates","getDistance","unit","arguments","undefined","options","units","getLength","line","getPolygonCenter","poly","getPolygonArea","overlay","Polygon","toGeoJSON","unionPolygon","polygons","i","len","isDisjoint","geometry1","geometry2","intersect","inputs","target","result","__proto__","Overlay","forEach","item","_item","isPass","push","isContains","outPoly","inPoly","isPointOnLine","pt","opts","ignoreEndVertices","Polyline","isPointInPolygon","ignoreBoundary","getDistance2Lines","pot","points","geoPoint","getNearestPointOnLine","geoOverlay","type","geoNearestPoint","bdNearestPoint","toLineDistance"],"sources":["C:/Users/29903/Desktop/毕业设计的各种准备/haidaoxiangmu/hias/node_modules/bmap-draw/es/calculate/geo-calculator.js"],"sourcesContent":["/**\n * @file 几何计算器\n * @author dengshufang01 [Flora]\n*/\nimport { midpoint, centroid, point, distance, lineString, length, area, union, booleanDisjoint, booleanContains, booleanPointOnLine, booleanPointInPolygon, pointToLineDistance, nearestPointOnLine, rhumbDistance } from '@turf/turf';\nexport var GeoCalculator = {\n  // 获取线段中点\n  getLineCenter: function getLineCenter(point1, point2) {\n    if (point1 instanceof BMapGL.Point && point2 instanceof BMapGL.Point) {\n      point1 = point([point1.lng, point1.lat]);\n      point2 = point([point2.lng, point2.lat]);\n    }\n    var geoCenter = midpoint(point1, point2);\n    var bdCenter = new BMapGL.Point(geoCenter.geometry.coordinates[0], geoCenter.geometry.coordinates[1]);\n    return {\n      geoCenter: geoCenter,\n      bdCenter: bdCenter\n    };\n  },\n  // 获取两点间距离\n  getDistance: function getDistance(point1, point2) {\n    var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'kilometers';\n    if (point1 instanceof BMapGL.Point && point2 instanceof BMapGL.Point) {\n      point1 = point([point1.lng, point1.lat]);\n      point2 = point([point2.lng, point2.lat]);\n    }\n    var options = {\n      units: unit\n    };\n    return distance(point1, point2, options);\n  },\n  /**\n      * 获取折线总距离\n      * @param line <GeoJSON> 折线\n      * @param unit 可选返回值单位，默认为km\n     */\n  getLength: function getLength(line) {\n    var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'kilometers';\n    return length(line, {\n      units: unit\n    });\n  },\n  /**\n   * 获取多边形区域中心\n   * @param poly geojson\n   * @return 中心点，包括 geojson 和 BMap.Point 两种格式\n  */\n  getPolygonCenter: function getPolygonCenter(poly) {\n    var geoCenter = centroid(poly);\n    var bdCenter = new BMapGL.Point(geoCenter.geometry.coordinates[0], geoCenter.geometry.coordinates[1]);\n    return {\n      geoCenter: geoCenter,\n      bdCenter: bdCenter\n    };\n  },\n  /**\n   * 获取多边形或矩形面积\n   * @param overlay <geojson | BMapGL.Polygon> 覆盖物\n   * @return 区域面积，单位：平方千米\n  */\n  getPolygonArea: function getPolygonArea(overlay) {\n    if (overlay instanceof BMapGL.Polygon) {\n      overlay = overlay.toGeoJSON();\n    }\n    return area(overlay) / 1000000;\n  },\n  /**\n   * 组合多边形\n   * @param polygons 两个或多个geojson格式的多边形\n   * @return 一个组合多边形\n   */\n  unionPolygon: function unionPolygon(polygons) {\n    var poly = polygons[0];\n    for (var i = 0, len = polygons.length; i < len; i++) {\n      poly = union(poly, polygons[i]);\n    }\n    return poly;\n  },\n  /**\n   * 判断两个几何图形是否相交\n   * @param geometry1 geojson格式的几何图形\n   * @param geometry2 geojson格式的几何图形\n   * @return 如果相交返回true\n   */\n  isDisjoint: function isDisjoint(geometry1, geometry2) {\n    return !booleanDisjoint(geometry1, geometry2);\n  },\n  /**\n   * 判断inputs数据是否与target数据相交\n   * @param inputs 相交运算数据集合，GeoJSON或者Overlay结构数据的数组\n   * @param target 相交运算数据，GeoJSON或者Overlay结构\n   * @returns 返回相交的数据集合，默认为[]\n   */\n  intersect: function intersect(inputs, target) {\n    var result = [];\n    if (target.__proto__ instanceof BMapGL.Overlay) {\n      if (target.toGeoJSON) {\n        target = target.toGeoJSON();\n      } else {\n        return result;\n      }\n    }\n    inputs.forEach(function (item) {\n      var _item = item;\n      if (item.__proto__ instanceof BMapGL.Overlay) {\n        if (item.toGeoJSON) {\n          _item = item.toGeoJSON();\n        } else {\n          return true;\n        }\n      }\n      var isPass = GeoCalculator.isDisjoint(_item, target);\n      if (isPass) {\n        result.push(item);\n      }\n    });\n    return result;\n  },\n  /**\n   * 判断几何图形是否包含\n   * @param outPoly geojson格式的几何图形，用于外部框选图形\n   * @param inPoly geojson格式的几何图形，用于内部被选图形\n   * @return 如果inPoly完全包含在outPoly内，返回true\n  */\n  isContains: function isContains(outPoly, inPoly) {\n    return booleanContains(outPoly, inPoly);\n  },\n  /**\n   * 判断点是否在线上\n   * @param pt <geojson | BMapGL.Point> 点\n   * @param line <GeoJSON | BMapGL.Polyline> 线\n   * @param opts <object> 可选配置忽略line的起始点与结束点\n   * @return <boolean> 点是否在线上\n  */\n  isPointOnLine: function isPointOnLine(pt, line) {\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      ignoreEndVertices: false\n    };\n    if (pt instanceof BMapGL.Point) {\n      pt = pt.toGeoJSON();\n    }\n    if (line instanceof BMapGL.Polyline) {\n      line = line.toGeoJSON();\n    }\n    return booleanPointOnLine(pt, line, opts);\n  },\n  /**\n   * 判断点是否在几何体内\n   * @param pt <geojson | BMapGL.Point> 点\n   * @param poly <geojson> 几何体（多边形、圆形、矩形）\n   * @param opts <object> 可选配置，是否包含多边形边界\n   * @return 如果在多边形内返回true\n   */\n  isPointInPolygon: function isPointInPolygon(pt, poly) {\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      ignoreBoundary: true\n    };\n    if (pt instanceof BMapGL.Point) {\n      pt = pt.toGeoJSON();\n    }\n    if (poly instanceof BMapGL.Polygon) {\n      poly = poly.toGeoJSON();\n    }\n    return booleanPointInPolygon(pt, poly, opts);\n  },\n  /**\n   * \n   * 获取点到多线段最短距离\n   * @param point 点\n   * @param points 点数组,一般getPath()获取\n   * @return 点到多线段最短距离，单位：千米\n   */\n  getDistance2Lines: function getDistance2Lines(pot, points) {\n    var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'kilometers';\n    var geoPoint = point([pot.lng, pot.lat]);\n    var line = lineString(points);\n    return pointToLineDistance(geoPoint, line);\n  },\n  /**\n   * 计算点到多线段最短间距点\n   */\n  getNearestPointOnLine: function getNearestPointOnLine(pot, geoOverlay) {\n    var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'kilometers';\n    var geoPoint = point([pot.lng, pot.lat]);\n    var coordinates = [];\n    if (geoOverlay.geometry.type === 'Polygon') {\n      coordinates = geoOverlay.geometry.coordinates[0];\n    } else if (geoOverlay.geometry.type === 'LineString') {\n      coordinates = geoOverlay.geometry.coordinates;\n    }\n    var line = lineString(coordinates);\n    var geoNearestPoint = nearestPointOnLine(line, geoPoint, unit);\n    var bdNearestPoint = new BMapGL.Point(geoNearestPoint.geometry.coordinates[0], geoNearestPoint.geometry.coordinates[1]);\n    var toLineDistance = distance(geoPoint, geoNearestPoint);\n    return {\n      geoPoint: geoPoint,\n      geoNearestPoint: geoNearestPoint,\n      toLineDistance: toLineDistance,\n      bdNearestPoint: bdNearestPoint\n    };\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}